1
00:00:00,000 --> 00:00:05,260
이 비디오에서는 포인터의 역참조에 관해 이야기해봅시다. 포인터의 역참조란 무엇일까요?

2
00:00:05,260 --> 00:00:10,020
포인터는 변수의 주소에 대한 참조이지만, 지금 주소 안에 무엇이 있는지와

3
00:00:10,020 --> 00:00:15,360
변수를 수정할 수 있다는 점을 눈여겨봐야 합니다. 이게 바로 포인터의 리얼 꿀잼 부분이죠.

4
00:00:15,820 --> 00:00:21,029
어떻게 할 수 있을까요? 언제나처럼, int ‘a’가 있습니다.

5
00:00:21,820 --> 00:00:28,740
그런 다음, 포인터 (int *ptr)을 만듭니다. 이건 int 포인터입니다.

6
00:00:28,960 --> 00:00:33,480
a에 56이란 값을 넣을게요. ptr이 a의 주소를 가지고 있게 합니다.

7
00:00:34,030 --> 00:00:40,680
a의 값을 표시해볼까요.

9
00:00:41,200 --> 00:00:45,839
지금부터 이 주제에 관해 이야기해봅시다. 여기 56이 있습니다.

10
00:00:45,940 --> 00:00:50,039
‘a’를 사용하지 않고 a의 값을 출력하려고 하면, ptr을 사용하면 됩니다.

11
00:00:50,789 --> 00:00:53,699
어떻게 할 수 있는 걸까요? ptr로 간단하게요.

12
00:00:53,699 --> 00:00:58,739
ptr은 a의 주소이므로, *ptr을 입력하면 컴파일러는 컴퓨터에

13
00:00:58,739 --> 00:01:05,500
ptr의 주소를 알려줍니다. 그리고 이 주소로 이동합니다.

14
00:01:05,920 --> 00:01:06,970
이후 주소 안의 값을 반환하거나 사용하죠.

15
00:01:06,970 --> 00:01:12,599
따라서 변수의 유형은 굉장히 중요합니다.

16
00:01:12,600 --> 00:01:14,080
*ptr을 사용할 때, 자세히 보자면

17
00:01:14,080 --> 00:01:16,229
(ptr은 pointer의 줄임말로, 포인터의 변수명으로 자주 사용됩니다)

18
00:01:16,990 --> 00:01:20,970
ptr은 int형 포인터이므로 *ptr는 int입니다.

19
00:01:20,970 --> 00:01:26,610
그래서 ‘*ptr’은 int입니다. 컴파일러가 이 ‘*ptr’이 int임을 알고 있습니다.

20
00:01:26,610 --> 00:01:29,249
그래서 ‘*ptr’을 int로서 printf 하려고 해도 문제가 없습니다.

21
00:01:29,890 --> 00:01:32,250
저장을 했고, 우리는 이것이 동작하는지 알 수 있습니다.

22
00:01:32,920 --> 00:01:34,920
56이 나왔으니까요!

23
00:01:35,140 --> 00:01:37,620
이것이 바로 역참조를 보는

24
00:01:37,840 --> 00:01:39,299
무식한 예시가 되겠습니다.

25
00:01:39,299 --> 00:01:42,449
또한 이렇게 포인터를 역참조하여 ‘a’의 값을 수정할 수도 있습니다.

26
00:01:42,670 --> 00:01:47,430
‘*ptr’ = 78이라고 입력하고서

27
00:01:48,369 --> 00:01:54,179
‘a’의 값을 출력해볼게요. ‘*ptr’을 쓰고, 그다음 ‘a’의 값을

28
00:01:54,180 --> 00:01:56,180
출력해봅시다.

29
00:01:57,040 --> 00:02:02,729
이제 이걸 실행시키면, 56과 78이 출력되는 것을 볼 수 있습니다.

30
00:02:03,040 --> 00:02:04,090
‘*ptr = 78’이라고 출력 전에 바꿔주었기 때문에 값이 변했습니다.

31
00:02:04,090 --> 00:02:08,639
이것은 무엇을 의미하는 걸까요? 먼저 등호 우측부터 계산하기 시작합니다.

32
00:02:08,639 --> 00:02:11,869
변수에 결괏값을 할당하고

33
00:02:12,300 --> 00:02:15,919
ptr이 가리키고 있는 값을 변경할 겁니다.

34
00:02:16,320 --> 00:02:19,639
이 경우에는 ‘a’이기 때문에 a가 원격으로 바뀐 것입니다.

35
00:02:20,460 --> 00:02:24,529
우리는 이것을 끝없이 할 수 있습니다.

36
00:02:25,620 --> 00:02:27,780
재미있는 것을 보여줄게요.

37
00:02:28,299 --> 00:02:33,359
작은 예시를 미리 준비했죠. ‘int a’가 있습니다.

38
00:02:33,700 --> 00:02:39,569
그리고 ‘a’의 주소를 가지고 있는 포인터 ‘int *ptr’도 있습니다.

39
00:02:40,239 --> 00:02:43,529
그리고 ‘ptr’의 주소 값을 가지고 있는 ‘ptr2’가 있고,

40
00:02:44,739 --> 00:02:49,169
‘ptr2’의 주소 값을 가지고 있는 ‘ptr3’가 있습니다.

41
00:02:49,720 --> 00:02:53,880
그리고 ‘ptr4’... 포인터가 늘어날 때마다 *이 하나씩 늘어나는 것을 볼 수 있습니다.

42
00:02:53,880 --> 00:02:59,300
int의 포인터의 포인터의 포인터의 포인터의 포인터. 그것은 ‘ptr3’의 주소 값을 제공합니다.

43
00:02:59,859 --> 00:03:04,079
‘ptr5’는 ‘ptr4’의 주소 값을 가지고 있고,

44
00:03:05,049 --> 00:03:06,849
마지막엔 ‘ptr6’가 있죠.

45
00:03:06,849 --> 00:03:08,849
‘ptr5’의 주소 값을 가지고 있어요.

46
00:03:09,700 --> 00:03:15,509
전부 컴파일되는지 살펴보죠. 오, 숫자 2를 빼먹었네요.

47
00:03:16,239 --> 00:03:21,029
정상적이라면 ‘a’의 값을 표시해야 합니다. 42를 출력했네요.

48
00:03:22,420 --> 00:03:27,030
‘ptr6’가 있고, 이를 사용하여 값 ‘a’를 표시하려면

49
00:03:27,730 --> 00:03:28,840
‘ptr6’는 포인터니까...

50
00:03:28,840 --> 00:03:33,329
int 형의 포인터의 포인터의 포인터의 포인터의 포인터.

51
00:03:33,880 --> 00:03:36,239
*을 여기에 있는 만큼 넣으면

52
00:03:36,370 --> 00:03:41,549
int 값을 얻을 수 있습니다. ‘ptr6’가 int 값의 포인터의 포인터의 포인터의 포인터……...의 값이기 때문입니다.

53
00:03:41,709 --> 00:03:45,449
*을 입력하면, 주소 값을 따라 이동하고 ‘ptr5’가 됩니다.

54
00:03:45,700 --> 00:03:47,470
주소 값이 있는 ‘ptr5’요.

55
00:03:47,470 --> 00:03:52,379
*을 추가하면 ‘ptr4’ 또 하나 하면 ‘ptr3’. 그렇게 ptr2. ptr.

56
00:03:52,599 --> 00:03:58,888
마지막에 ‘a’가 표시됩니다. 쉽게 말해서, 이 코드에서 원하는 값을 보기 위해서는

57
00:03:59,290 --> 00:04:03,929
*를 6개 입력해야 합니다. 문제가 없길 빌어보면서… 컴파일. 작동하네요. 유후!

58
00:04:04,329 --> 00:04:08,969
방금 포인터를 역참조하는 방법을 배웠습니다. 이건 아주 유용할 겁니다.

59
00:04:08,969 --> 00:04:12,689
포인터가 가리키는 변수에 접근하고, 수정할 수 있습니다.

60
00:04:13,120 --> 00:04:17,039
또는 이 변수를 직접 가지지 않은 채로 읽을 수 있을 겁니다.
<< translated by inyang, chelee, mki, yeslee, mseo and ji-kim :) >>
