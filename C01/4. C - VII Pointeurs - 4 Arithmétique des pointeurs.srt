1
00:00:00,000 --> 00:00:03,659
이번 영상에서는 포인터의 연산에 대해 얘기해보겠습니다.

2
00:00:03,659 --> 00:00:05,190
포인터는 자체적인 연산법이 있을 뿐만 아니라,

3
00:00:05,190 --> 00:00:07,970
긴 설명보다는 예시가 훨씬 더 유의미할 것입니다.

4
00:00:07,970 --> 00:00:12,240
언제나처럼 int가 있고

5
00:00:12,240 --> 00:00:14,849
int를 가리키는 포인터인 int *ptr이 있습니다.

6
00:00:14,849 --> 00:00:18,029
a의 주소를 ptr에 넣어주고

7
00:00:18,029 --> 00:00:19,500
그 주소를 출력해볼 거예요.

8
00:00:19,500 --> 00:00:20,609
제가 설명하고자 하는 건 여기서부터 시작입니다.

9
00:00:20,609 --> 00:00:23,010
일반적으로 int형으로 계산을 할 때,

10
00:00:23,010 --> 00:00:25,590
예를 들어 5 + 7을 한다면

11
00:00:25,590 --> 00:00:27,900
12의 값을 가지죠.

12
00:00:27,900 --> 00:00:29,730
포인터도 일반적인 연산 법칙을 따르지만

13
00:00:29,730 --> 00:00:31,140
아주 약간의 차이가 있고 거기엔 이유가 있습니다.

14
00:00:31,140 --> 00:00:32,940
바로 이해할 수 있을 겁니다.

15
00:00:32,940 --> 00:00:34,590
여기 ptr의 주소를 출력했고

16
00:00:34,590 --> 00:00:35,969
ptr + 1의 주소도 출력할 거예요.

17
00:00:35,969 --> 00:00:41,070
무슨 일이 일어나는지 보세요.

18
00:00:41,070 --> 00:00:42,860
두 ptr이 다르다는 걸 볼 수 있습니다.

19
00:00:42,860 --> 00:00:47,160
ptr도, ptr + 1도 주소인데,

20
00:00:47,160 --> 00:00:49,860
+ 1이 4만큼의 차이로 변했습니다. 왜일까요?

21
00:00:49,860 --> 00:00:55,379
ptr은 int형 포인터이기 때문입니다. 간단하죠.

22
00:00:55,379 --> 00:00:58,170
메모리를 1바이트만 움직이는 것은 말도 안 되는 일이에요.

23
00:00:58,170 --> 00:01:00,629
왜냐하면 int는 4바이트를 가지잖아요,

24
00:01:00,629 --> 00:01:02,430
만약 제가 1바이트씩 이동한다면

25
00:01:02,430 --> 00:01:03,780
int의 한중간에 있게 될 거예요.

26
00:01:03,780 --> 00:01:05,459
즉, 사실 포인터는 값을 가진답니다.

27
00:01:05,459 --> 00:01:06,540
포인터에는 주솟값이 있고, 그걸 딱 1바이트만 이동한다면,

28
00:01:06,540 --> 00:01:07,680
역시 이상할 거예요.

29
00:01:07,680 --> 00:01:10,200
제 int의 나머지 3바이트는 어쩌겠어요.

30
00:01:10,200 --> 00:01:12,030
그 옆에 있을 다른 바이트들도 이상해질 거예요.

31
00:01:12,030 --> 00:01:22,020
단순히 +1을 했을 때보다, +2, +10, +15를 해보면 더 재밌겠지만

32
00:01:22,020 --> 00:01:23,610
+2가 더 읽기 쉬우니까 예시로 들어보죠.

33
00:01:23,610 --> 00:01:27,509
자, 여기를 바꿨습니다.

34
00:01:27,509 --> 00:01:29,820
+2로 바뀌었으므로, 8바이트가 되었습니다.

35
00:01:29,820 --> 00:01:32,100
이건 우리가

36
00:01:32,100 --> 00:01:36,450
int 범위만큼 두 번 이동하게 해주네요.

37
00:01:36,450 --> 00:01:38,670
+2를 함으로써 저는 2만큼 떨어진 int가 되었고,

38
00:01:38,670 --> 00:01:41,100
int로 가득한 메모리에서도 옆옆 int로 움직이게끔 해줍니다.

39
00:01:41,100 --> 00:01:42,240
배열을 예시로 든다면

40
00:01:42,240 --> 00:01:43,890
가시적으로 볼 수 있을 거예요.

41
00:01:43,890 --> 00:01:45,149
이것도 계속해서 말할 겁니다.

42
00:01:45,149 --> 00:01:46,799
아무튼 배열 내에서 이동할 수 있게 해줍니다

43
00:01:46,799 --> 00:01:49,770
char형으로도 가능하다는 걸

44
00:01:49,770 --> 00:01:52,020
여러분께 보여드리겠습니다.

45
00:01:52,020 --> 00:01:53,579
그러니까 chars를 예로 들자면

46
00:01:53,579 --> 00:01:55,290
char는 1바이트를 가지니까

47
00:01:55,290 --> 00:01:56,759
동일한 ptr에

48
00:01:56,759 --> 00:01:58,649
+2를 했을 때,

49
00:01:58,649 --> 00:02:01,890
3b였던 원래 char *ptr의 주소가

50
00:02:01,890 --> 00:02:03,630
ptr +2일 때는 3d가 되는 거죠.

51
00:02:03,630 --> 00:02:06,420
왜냐하면 제가 2바이트를 옮겼으니까요.

52
00:02:06,420 --> 00:02:08,758
재미있는 걸 해보기 위해서

53
00:02:08,758 --> 00:02:13,790
포인터와 ptr을 통해 같은 동작을 해볼 거예요

54
00:02:13,790 --> 00:02:15,560
포인터를 가리키는 포인터를 만들어서 연산해보니

55
00:02:15,560 --> 00:02:19,490
바로 16바이트가 옮겨졌습니다.

56
00:02:19,490 --> 00:02:21,560
왜냐하면 +2를 할 경우에,

57
00:02:21,560 --> 00:02:23,210
포인터는 64비트 운영체제에서 8바이트를 가지기 때문이에요

58
00:02:23,210 --> 00:02:25,160
곱하기 2를 해주면 자, 16이죠.

59
00:02:25,160 --> 00:02:27,380
2만큼 옮기라고 했으니까요.

60
00:02:27,380 --> 00:02:29,600
재밌을지도 모르는 예시를 보여드릴게요

61
00:02:29,600 --> 00:02:30,980
int로 돌아가서

62
00:02:30,980 --> 00:02:37,460
int a와 int * ptr에

63
00:02:37,460 --> 00:02:39,500
또 다른 int인 b를 집어넣고

64
00:02:39,500 --> 00:02:40,760
a의 위에 둘게요.

65
00:02:40,760 --> 00:02:43,250
스택의 값은 위에서부터 내려온다는 걸 기억하시나요?

66
00:02:43,250 --> 00:02:45,680
이제 간단하게

67
00:02:45,680 --> 00:02:47,810
a의 주소를 가져와

68
00:02:47,810 --> 00:02:50,300
ptr의 주소를 출력해볼게요.

69
00:02:50,300 --> 00:02:51,530
한편,

70
00:02:51,530 --> 00:02:54,230
b의 주소를 출력하는 것도

71
00:02:54,230 --> 00:02:59,930
여기 &b를 넣는 거로 할 수 있어요

72
00:02:59,930 --> 00:03:02,180
제가 실수하지 않았다면

73
00:03:02,180 --> 00:03:03,950
b의 주소와 ptr +1의 주소를 볼 수 있습니다

74
00:03:03,950 --> 00:03:05,600
둘은 같은 거예요

75
00:03:05,600 --> 00:03:08,600
ptr은 a, a + 1의 주소를 가지고 있죠

76
00:03:08,600 --> 00:03:10,790
그러니 a + 1의 주소는 4바이트 먼 곳인 b에 있습니다

77
00:03:10,790 --> 00:03:12,110
스택은 아래로 내려온다고 말했죠?

78
00:03:12,110 --> 00:03:13,280
그런데 +1을 했을 때는 올라갔어요

79
00:03:13,280 --> 00:03:17,000
역참조를 통해 알아봅시다.

80
00:03:17,000 --> 00:03:25,040
b에 23의 값을 줬다고 상상해봅시다

81
00:03:25,040 --> 00:03:27,170
이제 b의 값을 출력해볼게요.

82
00:03:27,170 --> 00:03:30,740
a의 주소를 가지고 있는 ptr을 이용해서요

83
00:03:30,740 --> 00:03:33,320
잠시만요

84
00:03:33,320 --> 00:03:37,360
여기 %d와 *(ptr + 1)을 적을게요.

85
00:03:37,360 --> 00:03:40,340
왜냐하면 *은 연산자고,

86
00:03:40,340 --> 00:03:41,810
‘*’ 연산자는

87
00:03:41,810 --> 00:03:43,280
그 주소에 뭐가 있나 보라는 뜻이니까요

88
00:03:43,280 --> 00:03:45,530
ptr + 1은 *(ptr +1)의 주소이므로,

89
00:03:45,530 --> 00:03:48,770
ptr의 주소 +1에 뭐가 있나 볼 거예요

90
00:03:48,770 --> 00:03:50,120
간단한 수학을 해봅시다.

91
00:03:50,120 --> 00:03:53,000
먼저 컴파일러는 이 새로운 주소를 계산할 거예요

92
00:03:53,000 --> 00:03:54,020
그리고 마지막에 뭐가 있나 볼 거예요

93
00:03:54,020 --> 00:03:56,840
b가 나타났네요.

94
00:03:56,840 --> 00:03:58,340
실행해보면, 23이 출력되죠.

95
00:03:58,340 --> 00:04:00,920
언제나처럼

96
00:04:00,920 --> 00:04:03,560
마지막 변수의 값을 바꾸면서 재밌게 놀 수 있어요.

97
00:04:03,560 --> 00:04:05,960
완성 의지에 의거해서요.

98
00:04:05,960 --> 00:04:07,430
여러분에게 보여드릴게요.

99
00:04:07,430 --> 00:04:08,800
여기

100
00:04:08,800 --> 00:04:10,840
78을 준 다음에

101
00:04:10,840 --> 00:04:14,340
이제 printf %d를 가지고 놀아볼까요.

102
00:04:14,340 --> 00:04:17,798
잠시만요, printf(“%d\n”, b”)를 적으면,

103
00:04:17,798 --> 00:04:19,180
이제 b는 78의 값을 가질 거예요.

104
00:04:19,180 --> 00:04:23,980
포인터의 연산은 이런 식이므로

105
00:04:23,980 --> 00:04:25,240
포인터에 +1을 할 때

106
00:04:25,240 --> 00:04:27,030
정말로 조심해야 합니다.

107
00:04:27,030 --> 00:04:29,530
그러니까 하나의 주소를 가지게 되면,

108
00:04:29,530 --> 00:04:31,060
그 주소의 +1, -1 주소 역시 가질 수 있어요.

109
00:04:31,060 --> 00:04:33,500
+ 때와 동일하게 -1도 할 수 있습니다.

110
00:04:33,500 --> 00:04:35,870
b의 주소를 여기 가져와서

111
00:04:35,870 --> 00:04:40,160
예시로 -1을 넣는다고 한다면

112
00:04:40,160 --> 00:04:42,890
a에 갈 수 있어요.

113
00:04:42,890 --> 00:04:47,840
그러므로 여기 a에 12의 값을 넣고

114
00:04:47,840 --> 00:04:52,700
a의 값을 출력한다면

115
00:04:52,700 --> 00:04:55,760
12와 78이 출력될 거예요. 제가 실수하지 않았다면요.

116
00:04:55,760 --> 00:04:58,310
가봅시다… 아, 안되네요.

117
00:04:58,310 --> 00:05:00,350
제가 +1을 바꾸지 않았어요.

118
00:05:00,350 --> 00:05:02,510
-로 바꾸고 다시 해보면

119
00:05:02,510 --> 00:05:04,970
짠! 여기 12와 78이 나오죠.

120
00:05:04,970 --> 00:05:05,960
이 개념은 어느 정도는 넘어갈 수 있지만

121
00:05:05,960 --> 00:05:07,130
일반적으로, 그리고 음수 포인터에서도

122
00:05:07,130 --> 00:05:08,360
위험한 개념입니다.

123
00:05:08,360 --> 00:05:09,590
하지만 이걸 사용하는 건 여러분이고,

124
00:05:09,590 --> 00:05:11,120
컴파일러는 여러분의 행동에 동의할 거예요

125
00:05:11,120 --> 00:05:12,410
다시 한번 말하지만,

126
00:05:12,410 --> 00:05:15,470
일련의 주소가 있고,

127
00:05:15,470 --> 00:05:18,080
일련의 주소에 숫자를 더해도

128
00:05:18,080 --> 00:05:19,669
역시 주소입니다.

129
00:05:19,669 --> 00:05:21,110
‘*’이 있으면 * 뒤의 주소에

130
00:05:21,110 --> 00:05:22,340
뭐가 있는지 보라는 뜻입니다.

131
00:05:22,340 --> 00:05:24,770
포인터의 연산이 무슨 일을 하는지 이해하시겠나요?

132
00:05:24,770 --> 00:05:26,570
주의하세요, 1바이트를 늘리는 게 아니라,

133
00:05:26,570 --> 00:05:31,480
가리키는 자료형의 크기를 1 늘리는 거예요.
<< translated by yeslee, chelee, mseo, ji-kim, mki, and inyang :) >>
