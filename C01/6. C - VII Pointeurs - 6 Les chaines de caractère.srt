1
00:00:00,000 --> 00:00:04,049
이번 비디오에서는 string에 대해 얘기해봅시다.

2
00:00:04,049 --> 00:00:06,210
문자열은 개발자들이 효율을 위해 만든 것이지

3
00:00:06,210 --> 00:00:12,120
컴퓨터, 적어도 c언어에서는 존재하지 않습니다

4
00:00:12,120 --> 00:00:16,289
문자열은 값이 0인 바이트로 끝나는

5
00:00:16,289 --> 00:00:20,430
매우 간단한 바이트들의 모음입니다

6
00:00:20,430 --> 00:00:29,429
문자 A(a의 ASCII값)와 실제 값의 차이점을 완전히 이해하지 못한 사람들을 위해
 0의 값이 의미하는 바를 다시 설명하겠습니다

7
00:00:29,429 --> 00:00:38,160
ASCII 값 0(문자 ‘\0’)도 마찬가지입니다. 지금 보여드리죠

8
00:00:38,160 --> 00:00:42,809
다시 검토해보고 싶은 중요한 것이 있습니다.

9
00:00:42,809 --> 00:00:49,739
char c를 입력하고, c는 ‘0’이어서
그것이 ASCII 값 0이라는 것을 알 수 있습니다

10
00:00:49,739 --> 00:00:56,340
만약 숫자로 표시한다면,

11
00:00:56,340 --> 00:01:01,710
48과 같다는 것을 알 수 있습니다

12
00:01:01,710 --> 00:01:12,630
이제 c를 (48이 아닌) 0으로 쓸 수 있고

13
00:01:12,630 --> 00:01:16,890
결국 작성한 것과 같습니다,
잠시만요 미안합니다

14
00:01:16,890 --> 00:01:22,049
이것(0)은 이것(‘\0’)과 같습니다.
그래서 값이 0인 문자는 ‘\0’ 입니다, 갹!

15
00:01:22,049 --> 00:01:27,810
그래서 문자열은 단순한 바이트의 집합이며,

16
00:01:27,810 --> 00:01:32,820
0으로 끝납니다. 

17
00:01:32,820 --> 00:01:35,430
그러니까, 다시 한번 생각해보면 알 수 있는데...

18
00:01:35,430 --> 00:01:39,150
0으로 끝나는 문자열 집합은 이미 다음과 같습니다:

19
00:01:39,150 --> 00:01:44,970
char형 배열을 제외하고, 

20
00:01:44,970 --> 00:01:50,070
‘문자열’에서 마지막 문자는 0이어야만 합니다.

21
00:01:50,070 --> 00:01:53,399
10개의 요소를 할당하고, 

22
00:01:53,399 --> 00:01:57,090
't' 'o' 't' 'o' 't' 'o'를 넣었습니다.

23
00:01:57,090 --> 00:02:00,329
만약 ‘\0’이 마지막에 없다면 문자열로 보지 않는 문제가 생깁니다.

24
00:02:00,329 --> 00:02:03,899
이제 striing은 제대로 정의되지 않았다는 걸 이해하실 수 있을 겁니다…

25
00:02:03,899 --> 00:02:07,829
유일한 건 이 글자들은 읽을 수 있는 문자들이고 

26
00:02:07,829 --> 00:02:10,169
‘\0’으로 끝난다는 것입니다...

27
00:02:10,169 --> 00:02:12,260
이것이 정말로 ‘문자열’에 대해 알아야 할 유일한 것입니다.

28
00:02:12,260 --> 00:02:14,390
자, 이제 문자열을 가지고 놀 겁니다.

29
00:02:14,390 --> 00:02:18,560
일반적으로 포인터를 사용하여 ‘문자열’에 접근하여 수정할 것입니다

30
00:02:18,560 --> 00:02:22,010
야쓰! 왜냐하면 조금 전에 바이트 모음이라고 했잖아요

31
00:02:22,010 --> 00:02:26,299
one next to the other, and the last one
being 0... simply
그리고 마지막 바이트는 0…

32
00:02:26,299 --> 00:02:31,099
단순히 ‘str’은 문자에 대한 포인터가 될 것이고,
어떻게 문자열들을 쓸까요?

33
00:02:31,099 --> 00:02:34,670
예를 들어, str은 “lol”과 같고, 이제 str을 표시하겠습니다.

34
00:02:34,670 --> 00:02:41,780
여기서 흥미로운 점은 printf를 보면

35
00:02:41,780 --> 00:02:44,599
매개변수에 *str이 아니라 str을 적용했다는 겁니다.

36
00:02:44,599 --> 00:02:47,870
왜냐하면 *str은....

37
00:02:47,870 --> 00:02:51,440
I'll show you

38
00:02:51,440 --> 00:02:55,639
*str은 문자이므로 “%c”이기 때문입니다….
그러나 str은 주소이므로 “%s”입니다.

39
00:02:55,639 --> 00:03:01,010
이런…. 미안합니다, 이렇게 했을 때 두 번째 것을 넣는 걸 깜빡했어요.

40
00:03:01,010 --> 00:03:06,950
홉! *str 여기서…

41
00:03:06,950 --> 00:03:12,049
그리고 지금...

42
00:03:12,049 --> 00:03:16,459
str은 “lol”이지만, *str은 첫 번째 문자인 ‘l’의 주소고

43
00:03:16,459 --> 00:03:21,799
실제로 따옴표로 감싸서 “lol”을 쓸 때, 


44
00:03:21,799 --> 00:03:25,099
“I” ASCII 문자, “o” ASCII 문자, “I” ASCII 문자,
그리고 “0”을 메모리에 저장합니다.

45
00:03:25,099 --> 00:03:30,739
실제로는 메모리에 4개의 문자를 썼습니다

46
00:03:30,739 --> 00:03:34,040
문자열을 “”로 감싸면,

47
00:03:34,040 --> 00:03:37,250
상수라고 부르는 곳에 작성된다는 사실을 알아야 합니다.

48
00:03:37,250 --> 00:03:40,519
이것은 프로그램의 특정 위치이므로

49
00:03:40,519 --> 00:03:43,760
이 주소에서 따옴표로 묶인 값은 변경할 수는 없습니다.

50
00:03:43,760 --> 00:03:48,290
문자열은 쓰기 불가능한 영역에 있습니다.

51
00:03:48,290 --> 00:03:52,720
이게 여러분이 알아야 할 중요한 것입니다.

52
00:03:52,720 --> 00:03:56,329
첫 번째 요소인 str[0]을

53
00:03:56,329 --> 00:03:59,799
‘p’로 바꿔 쓰고 싶다면 하면 어떻게 될까요?

54
00:03:59,799 --> 00:04:05,120
여기에 쓸 수 없습니다…
bus error가 일어났습니다!

55
00:04:05,120 --> 00:04:10,099
함수를 거치지 않고, 메모리에 할당하지 않고, 

56
00:04:10,099 --> 00:04:12,919
C에서 복잡한 작업을 수행하지 않는 방법은 “str[]”로 작성하는 것입니다.

57
00:04:12,919 --> 00:04:17,029
크기를 지정하지 않고 직접 할당한다는 점을 제외하면 

58
00:04:17,029 --> 00:04:20,499
정적 배열을 선언하는 것과 같습니다

59
00:04:20,500 --> 00:04:23,060
다음 줄에 할당하면 동작하지 않습니다...

60
00:04:23,060 --> 00:04:28,930
이제 원하는 작업을 할 수 있습니다

61
00:04:28,930 --> 00:04:33,680
이제 첫 글자에 ‘p’가 있고 ‘pol’이 표시됩니다.

62
00:04:33,680 --> 00:04:38,870
요약: 일반적으로 문자열은 첫 번째 주소의 주소이기 때문에 

63
00:04:38,870 --> 00:04:42,560
char *를 통해 접근한 다음

64
00:04:42,560 --> 00:04:46,010
값이 0인 문자를 찾을 때까지 진행해야 합니다.

65
00:04:46,010 --> 00:04:50,770
이것이 문자열을 정의하는 방법입니다!
<< translated by mseo, ji-kim, inyang, chelee, mki and yeslee :) >>
