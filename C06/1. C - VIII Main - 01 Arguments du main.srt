1
00:00:05,589 --> 00:00:08,632
이 영상에서는 main의 인자들에 대한 개념을 배워봅시다.

2
00:00:08,632 --> 00:00:10,979
이미 “Main” 함수를 여러 번 사용했지만

3
00:00:11,349 --> 00:00:15,389
그 인자들은 한 번도 사용하지 않았죠. 이제 그것들이 꽤 유용하다는 것을 알게 될 겁니다.

4
00:00:15,910 --> 00:00:20,600
우선, 이 주제에 대해 더 배우기 전에, 포인터 영상 보기를 강력히 추천합니다.

5
00:00:20,600 --> 00:00:23,369
그 영상을 완벽히 이해하셔야 합니다.

6
00:00:23,369 --> 00:00:25,369
여기서 무슨 일이 일어나는지 이해하는데 필요한 개념을 다루기 때문이죠.

7
00:00:25,900 --> 00:00:30,240
일단 예시로 시작하겠습니다.

8
00:00:30,970 --> 00:00:35,200
자, 익숙한 “int main void”가 있습니다. 변수로 넘어가기에 앞서,

9
00:00:35,200 --> 00:00:37,529
void 부분을 바꿔보도록 하겠습니다.

10
00:00:38,200 --> 00:00:43,200
반환 값을 보면, “main”은 “int”를 반환합니다.

11
00:00:43,200 --> 00:00:46,829
관례로 함수를 C에서 컴파일하려면 무언가를 반환해야 합니다.

12
00:00:47,050 --> 00:00:52,000
지금 이 함수가 int를 반환한다고 선언했으니, 만약 int를 반환하지 않는다면

13
00:00:52,000 --> 00:00:56,969
컴파일러는 호통을 칠 것입니다. 하지만 운이 좋게도 GCC는, “main” 함수의 경우

14
00:00:57,460 --> 00:01:03,300
자동으로 0을 반환해주니 아무 문제가 없죠.

15
00:01:03,570 --> 00:01:05,647
GCC가 반환해주는 겁니다. 

16
00:01:05,647 --> 00:01:10,320
확인해 보죠. 여기에 쉘 변수 “$?”를 넣으면

17
00:01:10,810 --> 00:01:12,810
이전 명령어의 반환값을 보여줍니다.

18
00:01:13,540 --> 00:01:17,740
여기 반환값 “0”이 의미하는 바는, 

19
00:01:17,740 --> 00:01:20,129
프로그램이 어떠한 에러 없이 잘 실행됐다가 종료되었다는 것입니다.

20
00:01:20,530 --> 00:01:24,570
그러니까 “&&”를 이용하는 방식은 유용하죠.

21
00:01:24,880 --> 00:01:28,012
왜냐하면 다음 절차를 밟기 전에, 모든 게 잘 작동했다는 사실을 확인할 수 있기 때문입니다. 
 
22
00:01:28,012 --> 00:01:29,909
“$?”의 값이 0이라면, 다음 절차로 넘어가면 됩니다.

23
00:01:29,909 --> 00:01:33,985
반대로, 만약 코드에 에러가 있다는 사실을 깨달았다면 어떨까요.

24
00:01:33,985 --> 00:01:36,299
실제로는 없지만, 있다고 상상해봅시다.

25
00:01:36,299 --> 00:01:40,799
그러니까, 에러가 있어서 7을 반환한다고 합시다.

26
00:01:42,820 --> 00:01:45,200
이제 다시 컴파일하고 이 변수를 확인하면

27
00:01:45,200 --> 00:01:47,849
7이 있죠. 그러므로 계속 명령어를 실행하는 것을 멈추겠죠.

28
00:01:47,950 --> 00:01:51,320
예를 들어 “&&”가 들어간 쉘 명령어 같은 것들 말입니다.

29
00:01:51,320 --> 00:01:52,920
문제가 있다고 말하고 있으니까요. 

30
00:01:53,470 --> 00:01:58,739
그러니 관례로, “Main” 함수가 항상 0을 반환하며 종료해야 한다는 사실은 매우 중요합니다.

31
00:01:58,930 --> 00:02:03,149
자, 여기 마지막 줄에, 그러니까 이 프로그램의 끝에 0을 반환합니다. 모든 게 잘 마무리됐다는 뜻이죠.

32
00:02:04,509 --> 00:02:07,709
이것이 반환값입니다. 이제 변수에 관해 얘기해 보죠.

33
00:02:08,470 --> 00:02:13,200
여기에는 3개의 변수가 있습니다. 첫 번째는 “argc”라 불리는 int형 변수입니다.

34
00:02:13,200 --> 00:02:17,618
다른 이름으로 불러도 되지만, 관례로 “argc”라고 불립니다.

35
00:02:17,618 --> 00:02:21,300
왜 “argc”냐구요? “arg count”를 의미하기 때문이지요.

36
00:02:21,300 --> 00:02:25,530
프로그램이 받은 매개변수의 개수를 알려줍니다. 

37
00:02:26,050 --> 00:02:29,000
여기에 꼭 알아야 할 중요한 사실이 하나 있습니다.

38
00:02:29,000 --> 00:02:32,279
프로그램 이름도 매개변수의 개수에 포함이 된다는 점입니다.

39
00:02:32,590 --> 00:02:35,550
그러니까 매개변수가 없을 때도 “argc”는 1의 값을 가집니다.

40
00:02:36,730 --> 00:02:38,110
이것이 첫 번째 변수입니다.

41
00:02:38,110 --> 00:02:44,639
자, 이제 받아온 매개변수의 값에 접근하고 싶겠죠. 관례로 이 변수는 “arg value”라는 뜻으로 “argv”라고 부릅니다. 

42
00:02:44,920 --> 00:02:50,000
“char **”형입니다. 배열의 첫 번째 원소의 주소를 가리키죠. 

43
00:02:50,000 --> 00:02:54,200
이 배열은 프로그램이 받은 각 매개변수를 담고 있습니다. 

44
00:02:54,200 --> 00:02:58,559
다시 말해, 매개변수로 들어온 각 문자열의 시작 주소를 담고 있는 겁니다.

45
00:02:59,020 --> 00:03:03,000
덕분에 매개변수에 접근할 수 있죠.

46
00:03:03,000 --> 00:03:06,270
main의 마지막 매개변수로, 같은 원리를 사용하는 “char **environ”이 있습니다.

47
00:03:06,910 --> 00:03:10,379
이것은 쉘의 환경변수에 

48
00:03:10,379 --> 00:03:12,660
접근하도록 도와줍니다.

49
00:03:12,820 --> 00:03:14,909
쉘 안에서 무슨 일이 일어나고 있는지 먼저 봅시다.

50
00:03:15,100 --> 00:03:18,287
“env” 명령어를 써서 보지요. 보시다시피 몇 가지가 있습니다. 

51
00:03:18,287 --> 00:03:20,909
예를 들어 지금 경로가 어떻게 되는지를 알기 위해서

52
00:03:21,459 --> 00:03:24,509
매우 유용하게도 “pwd”를 사용할 수 있습니다. 이것이 다  “environ” 변수 덕분이죠.

53
00:03:25,360 --> 00:03:28,800
뭐, 매일 사용하지도 않고

54
00:03:28,800 --> 00:03:31,589
90%의 경우로 쓰지 않을 때가 많지만, 이런 게 존재한다는 사실을 아는 것만으로도 유용하죠.

55
00:03:32,019 --> 00:03:34,229
일단 지금으로서는 사용하지 않겠습니다.

56
00:03:35,320 --> 00:03:38,417
두 번째로 중요한 포인트가 있습니다. 여기에 “argc”와 “argv”라고 명명했지만

57
00:03:38,417 --> 00:03:40,469
알아야 할 중요한 사실은,

58
00:03:40,470 --> 00:03:43,619
변수명을 원하는 대로 바꿀 수 있다는 것입니다. 지킬 것을 지키면 말이죠.

59
00:03:44,049 --> 00:03:47,609
main이 받는 첫 번째 변수, 예를 들어 “ac”이라고 바꿔 불러도

60
00:03:47,860 --> 00:03:51,300
이 변수는 항상 “int”형입니다. 값을 저장하는 두 번째 변수는 항상 “char **”형이고요. 

61
00:03:51,300 --> 00:03:53,070
세 번째 역시 “char **”입니다.

62
00:03:53,140 --> 00:03:56,190
환경 변수를 받는 변수죠. 뭐라고 부르든 상관없습니다.

63
00:03:56,680 --> 00:04:00,540
여기선 관례적인 이름을 계속 쓰도록 하죠. 컴파일하면 무슨 일이 일어나는지 봅시다.

64
00:04:03,970 --> 00:04:07,499
변수들을 사용하고 있지 않다는 에러문이 뜨는군요. 그럼 이렇게 하죠...

65
00:04:09,640 --> 00:04:11,640
이렇게 적고...

66
00:04:16,139 --> 00:04:20,629
이제 컴파일러가 조금 만족해하는군요. 인자들을 인식했고 아무 문제 없습니다.

67
00:04:21,089 --> 00:04:27,500
“argc”의 값을 출력해 봅시다. 인자의 개수를 보여주겠죠.

68
00:04:36,930 --> 00:04:38,250
전에 말했듯이, 

69
00:04:38,250 --> 00:04:40,347
인자 개수는 1개입니다. 

70
00:04:40,347 --> 00:04:43,130
프로그램 이름인 “a.out” 이

71
00:04:43,230 --> 00:04:45,979
인자의 한 부분이기 때문이지요.

72
00:04:46,560 --> 00:04:53,500
이제 인자 값을 출력해 봅시다. 

73
00:04:53,550 --> 00:04:55,550
어떤 인자인지 지정해 줘야 합니다.

74
00:04:58,020 --> 00:05:00,049
"Argument value: %s\n"

75
00:05:01,500 --> 00:05:05,510
값은 항상 문자열입니다. 아무리, 예를 들어, “6”을 적어도 

76
00:05:05,910 --> 00:05:10,400
이 “6”은 정수 매개변수가 아닌 문자열로 받아들여집니다. 

77
00:05:10,400 --> 00:05:12,290
만약 정수로 쓰고 싶다면,

78
00:05:12,290 --> 00:05:15,890
변환해야 합니다. 그건 여러분이 알아서 찾아보세요. 

79
00:05:18,960 --> 00:05:23,239
어쨌거나, 여기 “argv”를 이용해 첫 번째 인자의 주소에 접근해보겠습니다.

80
00:05:24,150 --> 00:05:29,600
문자열을 출력할 겁니다. 첫 번째 인자는, 

81
00:05:31,800 --> 00:05:35,179
전에도 말했듯이, 프로그램 이름입니다.

82
00:05:35,400 --> 00:05:39,500
재밌는 것을 보여드리자면, 여기에 “lol”이라고 적고 

83
00:05:40,830 --> 00:05:45,590
두 번째 인자(argv[1])를 출력하면

84
00:05:47,639 --> 00:05:50,538
두 번째 인자값이 보이죠. “lol”입니다.

85
00:05:50,690 --> 00:05:52,780
인자 개수 역시 2개로 는 게 보이죠?

86
00:05:52,780 --> 00:05:57,079
인자를 하나 추가했으니까요. 만약 더 많이 추가한다면,

87
00:05:57,930 --> 00:06:01,070
인자 개수도 늘겠죠? “lol”은 내버려 두고 더 쓰면...

88
00:06:01,800 --> 00:06:04,800
이걸 사용하면 프로그램에 입력한 매개변수에 접근할 수 있고 

89
00:06:04,800 --> 00:06:08,400
그것을 가지고 무언가를 할 수 있습니다. 

91
00:06:08,400 --> 00:06:09,539
그러니까 

92
00:06:09,539 --> 00:06:13,699
함수를 작성할 때 매우 유용하죠. 프로그램의 어떤 것을 테스트해보고 싶다면

93
00:06:13,770 --> 00:06:17,165
그것을 매개변수로 전달할 수도 있습니다. 그러면 매번 다시 컴파일하지 않아도 되죠.

94
00:06:17,165 --> 00:06:18,919
매개변수로 다른 값을 주면 되니까요.

95
00:06:20,250 --> 00:06:24,200
마지막으로 매개변수를 변수에 저장해서

96
00:06:24,220 --> 00:06:27,850
당신의 코드로 그 데이터를 처리할 수도 있습니다. 간단한 예시를 들어보죠.

97
00:06:28,400 --> 00:06:30,400
si je fais un char étoile
if I declare a "char *str"
“char *str”을 선언하고 

98
00:06:30,920 --> 00:06:37,869
argv[1]의 값을 줍니다. 그러면 “lol”을 이 변수에 저장하는 것과 같습니다. 

99
00:06:38,420 --> 00:06:39,830
간단하죠.

100
00:06:39,830 --> 00:06:42,340
이 변수를 써봅시다… 출력해 보죠.

101
00:06:57,240 --> 00:06:59,700
보시다시피 “lol”을 출력했습니다. 

102
00:06:59,700 --> 00:07:01,699
새로 만든 “char *str”에 저장된 값이죠.

103
00:07:02,250 --> 00:07:04,250
이제 프로그램으로 인자를 

104
00:07:05,009 --> 00:07:10,549
받고, 사용하고, 개수를 세는 방법을 배웠습니다. 알차게 쓰세요!
<< translated by inyang, mki, yeslee, mseo and ji-kim :) >>
