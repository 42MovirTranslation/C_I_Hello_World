1
00:00:00,000 --> 00:00:02,070
이번 비디오에서는, struct(구조체)에 대해 이야기하겠습니다.

2
00:00:02,560 --> 00:00:07,500
struct는 typedef와 유사합니다. 같은 범위에서 동일하게 동작하고,

3
00:00:07,599 --> 00:00:10,799
새로운 변수 유형을 정의할 수도 있습니다.

4
00:00:10,860 --> 00:00:14,580
하지만, typedef는 이미 존재하는 변수 유형을 선택하여

5
00:00:14,889 --> 00:00:18,509
이름을 바꿔 새로운 유형을 정의하게 해주었다면,

6
00:00:18,640 --> 00:00:23,580
struct는 기존 변수 유형을 동일한 구조에 결합함으로써

7
00:00:24,039 --> 00:00:30,688
새로운 유형의 변수를 만들 수 있게 해줍니다. 예시를 봅시다.

8
00:00:31,330 --> 00:00:34,680
tab이라고 이름 붙인 int배열이 있다고 상상해봅시다.

9
00:00:35,610 --> 00:00:40,020
이 배열은 2D 공간에서 다른 점을 나타냅니다.

10
00:00:40,150 --> 00:00:44,400
tab[3][2]는 2D 공간의 int형 좌표를 포함하고 있습니다.

11
00:00:45,010 --> 00:00:50,129
지금까지 어떤 문제도 없지만, 오해의 소지가 있을 수는 있습니다.

12
00:00:50,620 --> 00:00:52,620
three points in 2-D
2줄 3칸짜리 좌표이거나

13
00:00:52,690 --> 00:00:57,719
3줄 2칸짜리 좌표일지 말이에요. 그건 여러분의 판단에 달려있습니다.

14
00:00:58,120 --> 00:01:02,099
일반적으로, 사람들은 2줄 3칸으로 보지만, 실제로는

15
00:01:02,440 --> 00:01:06,569
언제나 6칸의 배열이 될 것입니다.

16
00:01:07,300 --> 00:01:11,009
그래서, tab[3][2]에 있는 사실이 명확하지 않다는 것을 여러분은 이미 알 수 있습니다.

17
00:01:11,009 --> 00:01:12,580
우리에겐 2차원의 점들이 있습니다.

18
00:01:12,580 --> 00:01:14,440
자세히 알아봅시다.

19
00:01:14,440 --> 00:01:17,459
값을 이렇게 넣었습니다. tab[0][0] = 1.. 이런 식으로요.

20
00:01:17,710 --> 00:01:23,820
그리고 여기를 봐야 해요. tab[2] = tab[0]이라고 썼습니다.

21
00:01:24,369 --> 00:01:26,369
포인트 [0]을

22
00:01:26,979 --> 00:01:30,059
포인트 [2]에 복사하고 싶다고 썼어요. 무슨 일이 일어날까요.

23
00:01:33,280 --> 00:01:34,570
에러가 났네요!

24
00:01:34,570 --> 00:01:40,139
컴파일러는 내가 하려고 하는 것을 이해하지 못했고, int[2]에 무언가… 할당하려고 했다고 알려줍니다.

25
00:01:40,780 --> 00:01:42,340
글쎄요, 명확하지 않네요.

26
00:01:42,340 --> 00:01:47,280
컴파일러는 “이런 작업 못 합니다”라고 말합니다. struct를 사용하면 이런 종류의 작업을 수행할 수 있습니다.

27
00:01:47,280 --> 00:01:49,280
시간을 조금 절약할 수 있습니다.

28
00:01:49,360 --> 00:01:53,400
이제 struct유형의 새 변수를 작성하는 법을 보여드리겠습니다.

29
00:01:53,660 --> 00:01:59,800
간단히 말해서, 선언하면 됩니다. 그래서 일단 키워드인 struct를 쓰고 이름을 씁니다.

30
00:02:00,640 --> 00:02:02,640
이 뒤에 우리는 “{};”를 넣어야 합니다.

31
00:02:02,890 --> 00:02:09,630
그리고 중괄호 안에 우리의 struct를 구성하는 다른 것을 씁니다. 그래서 여기에

32
00:02:10,060 --> 00:02:12,149
x를 나타내는 int와 y를 나타내는 int를 쓰고...

33
00:02:13,000 --> 00:02:15,000
이제 이걸 어떻게 쓸까요?

34
00:02:15,370 --> 00:02:19,080
간단합니다. 여기에 struct s_point라고 씁니다.

35
00:02:19,780 --> 00:02:21,780
그리고 이건([2]) 삭제하겠습니다.

36
00:02:23,830 --> 00:02:28,199
이제 struct s_point 배열을 선언합니다. (struct s_point tab[3])

37
00:02:28,930 --> 00:02:30,760
여기까지는 매우 쉽습니다.

38
00:02:30,760 --> 00:02:38,070
이제, 더 이상 [0][0]을 액세스할 수 없습니다. 따라서 tab은 struct s_point의 배열이므로

39
00:02:38,380 --> 00:02:45,130
tab[0]도 struct s_point입니다. 이걸 어떻게 액세스 할 수 있을까요. ‘.x’를 사용하면 됩니다.

40
00:02:45,520 --> 00:02:50,900
y는 ‘.y’로 액세스하려면 간단합니다. 여기에 tab[1]이 표시하고...

41
00:02:51,160 --> 00:02:55,680
‘.x’로 액세스할 수도 있고, ‘.y’로도 액세스 할 수 있습니다.

42
00:02:55,940 --> 00:02:58,500
그리고… ‘.y’로 대체할게요.

43
00:03:00,660 --> 00:03:02,140
여긴 ‘.x’ 그리고 얍.

44
00:03:02,540 --> 00:03:05,620
다시 컴파일하면, 이번에는 동작합니다.

45
00:03:05,870 --> 00:03:10,600
값을 보여줄 뿐만 아니라 이 줄이 완벽하게 동작한다는 것도 중요한 부분입니다.

46
00:03:11,750 --> 00:03:13,750
왜냐면 여기 왼쪽에

47
00:03:13,970 --> 00:03:18,550
struct s_point형의 tab[2]가 있고, 오른쪽 또한 같은 struct s_point형의 tab[0]가 있습니다.

48
00:03:18,680 --> 00:03:22,540
컴파일러는 ‘struct s_point가 무엇인지 알고 있습니다. struct은 두 개의 int형 변수를 만들어 묶어두고

49
00:03:22,760 --> 00:03:25,989
직접 복사할 수 있기 때문에 정말 유용합니다.

50
00:03:26,690 --> 00:03:31,269
struct 안의 값은 세트입니다. 이건 좌표이고,

51
00:03:31,459 --> 00:03:35,079
이전에 두 개의 정수로 이루어진 tab과는 다릅니다. 이제 의미가 있고, 함께 정의됩니다.

52
00:03:35,290 --> 00:03:39,130
이제, 내 구조의 내용을 다른 구조로도 복사 할 수 있습니다.

53
00:03:39,200 --> 00:03:43,239
그리고 우리는 내가 한 점을 다른 점으로 복사하고 있음도 이해했습니다.

54
00:03:43,450 --> 00:03:48,429
tab[0][0]을 tab[1][0]에, tab[0][1]을 tab[1][1]에 각각 복사해야 했지만

55
00:03:49,190 --> 00:03:54,380
두 개의 복사본을 만드는 대신에 이젠 한 번에 두 가지를 복사합니다.

56
00:03:55,620 --> 00:03:57,620
또 다른 것을 보여드릴게요.

57
00:03:57,870 --> 00:03:59,070
이걸 어떻게 쓰는지 보여드릴게요.

58
00:03:59,070 --> 00:04:05,959
tab[0].x가 있습니다.

59
00:04:06,930 --> 00:04:11,599
(*tab).x로 쓰여있죠. tab[0]은 *tab과 같습니다.

60
00:04:12,390 --> 00:04:19,850
자 이제, 이걸 또 다르게 써볼게요. tab->x = 1

61
00:04:21,149 --> 00:04:22,139
->x는 tab을 참조하고 .을 사용하는 것과 같습니다.

62
00:04:27,690 --> 00:04:31,130
따라서 화살표는 역참조(*)와 점(.)을 함께 쓰는 것입니다.

63
00:04:31,710 --> 00:04:38,180
그래서 이건 그저 똑같은 것을 쓰는 또 다른 방법일 뿐입니다.
이게 동작한다는 것을 보여주기 위해… 컴파일하면… 아무 문제가 없습니다.

64
00:04:39,090 --> 00:04:41,090
또 다른 중요한 것은

65
00:04:41,310 --> 00:04:45,859
typedef와 struct를 동시에 사용할 수 있습니다. 거의 항상 이런 식으로 사용됩니다.

66
00:04:45,860 --> 00:04:51,290
struct s_point를 다시 쓸게요. 이건 별로 실용적이지 않은 함수에요. 여기에 typedef를 씁니다.

67
00:04:52,380 --> 00:04:57,980
typedef를 쓰고 나서, 우리는 재정의할 유형을 주어야 하고 이걸 struct s_point로 주고

68
00:04:58,169 --> 00:05:00,169
이걸 t_point로 쓸게요.

69
00:05:00,750 --> 00:05:03,410
여기에서 사용하려면, t_point라고

70
00:05:06,600 --> 00:05:08,370
대체해야 합니다.

71
00:05:08,370 --> 00:05:11,060
짠, 컴파일이 되고 잘 작동합니다.

72
00:05:11,730 --> 00:05:13,759
우리는 typedef와 struct를 같이 사용했습니다.

73
00:05:14,100 --> 00:05:19,100
동시에 정의한 struct s_point의 이름을 변경했습니다. 컴파일러에게는 문제가 되지 않습니다.

74
00:05:19,100 --> 00:05:24,200
그래서 방금 정의된 struct s_point도 이름이 바뀌었습니다.

75
00:05:24,510 --> 00:05:28,459
(사실 이름이 바뀌지 않았습니다. struct s_point를 아직 사용할 수 있습니다)

76
00:05:28,919 --> 00:05:34,249
하지만 이제는 struct s_point 대신 t_point를 사용할 수도 있습니다. 쓰기 더 쉬워요.

77
00:05:34,250 --> 00:05:36,709
typedef와 struct를 함께 사용하는 것이 좋습니다.

78
00:05:37,950 --> 00:05:42,469
마지막으로 중요한 것은 다음과 같습니다.

79
00:05:43,470 --> 00:05:47,989
각 유형마다 크기가 있다는 것을 알고 있을 겁니다.

80
00:05:48,600 --> 00:05:49,870
쓸모없는 건 지워 버립시다.

81
00:05:49,870 --> 00:05:54,270
sizeof라는 키워드를 사용할 것입니다. 다른 동영상에서 이미 봤을 수도 있습니다.

82
00:05:55,420 --> 00:06:01,469
이 키워드는 변수의 크기를 검색할 수 있는 키워드입니다.

83
00:06:01,660 --> 00:06:05,999
컴파일을 할 때, 이것은 컴파일러의 키워드입니다.

84
00:06:06,580 --> 00:06:08,580
그래서, 내가 sizeof(i)를 쓰면

85
00:06:08,710 --> 00:06:14,070
i의 크기를 알 수 있습니다.

86
00:06:14,560 --> 00:06:17,760
여기에 tab[0]을 쓰면

87
00:06:19,390 --> 00:06:24,390
t_point의 크기를 알 수 있으므로 struct s_point의 크기를 알 수 있습니다.

88
00:06:26,590 --> 00:06:31,679
여기 4와 8을 얻었네요. 8은 두 개의 정수가 있기 때문일 겁니다.

89
00:06:33,810 --> 00:06:38,850
구조의 또 다른 장점은 반드시 같은 타입이 아닌 다른 타입의 요소도 추가할 수 있다는 것입니다.

90
00:06:38,850 --> 00:06:42,239
예시를 위해 char *name을 쓸게요.

91
00:06:42,760 --> 00:06:44,760
여기서, 이건 지금 좌표를 나타내는 것이 아닙니다.

92
00:06:45,070 --> 00:06:45,820
(이 좌표에는 int x와 int y가 들어 있습니다)

93
00:06:45,820 --> 00:06:50,489
하지만 이름을 줄 수 있습니다. 그리고 내가 이 좌표를 복사하고 싶다면

94
00:06:50,490 --> 00:06:54,090
이 정보는 struct의 일부이므로 이름도 복사합니다. 주의하세요.
이 복사는 “* char”를 복사하여 주소를 복사하는 겁니다.

95
00:06:54,400 --> 00:06:58,830
주소의 내용을 복사하지는 않습니다. 조심하세요.

96
00:06:59,290 --> 00:07:01,180
제가 보여드리고 싶은 것은

97
00:07:01,180 --> 00:07:08,310
다시 컴파일하고 실행하면, t_point의 크기는 16입니다.

98
00:07:08,560 --> 00:07:12,179
첫 int는 4였고, 두 번째 int가 더해져 8이 되고,

99
00:07:12,400 --> 00:07:18,810
그리고 char *는 8이라서 4 + 4 = 8 + 8 = 16이 됩니다

100
00:07:19,120 --> 00:07:21,120
짜잔, 이제 우리는 크기가 16인 struct를

101
00:07:21,520 --> 00:07:23,380
가지고 있습니다.

102
00:07:23,380 --> 00:07:27,659
이것을 이해하는 것은 중요합니다. 그래서 우리가 struct에 무언가를 추가할 때마다

103
00:07:27,850 --> 00:07:32,100
할당하자마자 16byte로 할당할 것을 기억하십시오.

104
00:07:33,080 --> 00:07:34,669
이것은 더 큰 struct을 사용하기 시작할 때

105
00:07:34,669 --> 00:07:38,978
주의해야 할 부분입니다. 사용하지 않는 값이 있을 수도 있을 거예요.

106
00:07:39,440 --> 00:07:43,059
몇 개의 작은 struct로 나누는 것은 가치가 있을 수 있습니다. 이 일은 나중에 생각합시다.

107
00:07:43,610 --> 00:07:46,900
그래서, 우리는 오늘 struct에 대한 모든 것을 알아봤습니다.

108
00:07:47,479 --> 00:07:48,770
모든 것을 이해하셨기를 바랍니다.

109
00:07:48,770 --> 00:07:49,940
그건 매우 유용한 것이고

110
00:07:49,940 --> 00:07:54,729
c를 제외하고도 여러 언어에서 사용됩니다.

111
00:07:55,070 --> 00:07:58,119
또한 객체와 OOP에 대해 이야기 할 테니, 나중에 더 가서 볼 수 있을 겁니다.

112
00:07:58,669 --> 00:08:03,309
따라서 사용을 두려워하지 마십시오. 매우 중요하고, 유용합니다.
<< translated by inyang, ji-kim, yeslee, mki and mseo :) >>
