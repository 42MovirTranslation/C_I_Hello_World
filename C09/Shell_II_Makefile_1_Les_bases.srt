1
00:00:00,099 --> 00:00:06,119
환영합니다. 이번 영상에서는 Makefile에 대해 알아보겠습니다. Makefile은 우리가 여러 규칙들을 체계적으로 적용시켜

2
00:00:06,490 --> 00:00:08,490
컴파일할 수 있도록 해주는 특정한 파일입니다.

3
00:00:08,980 --> 00:00:14,790
그러면 미리 준비해둔 이 두 가지 .c 파일로 이루어진, 아주 간단한 프로젝트를 실행시켜 봅시다.

4
00:00:15,130 --> 00:00:21,029
어떻게 컴파일하는지도 봅시다. 만약 커맨드라인에서 직접 컴파일한다면,

5
00:00:21,279 --> 00:00:25,139
예를 들어, 저는 “hello”라는 파일을 생성할 겁니다. 왜냐하면 hello world를 출력하는 단순한 코드니까요.

7
00:00:28,269 --> 00:00:30,269
그리고 컴파일러에게 제 .c 파일들을 넘겨주겠습니다… (main.c, fct.c)

8
00:00:32,169 --> 00:00:34,499
실행가능한 Hello 파일이 생성되었네요.

9
00:00:36,219 --> 00:00:39,779
같은 것을 Makefile로 해봅시다.

10
00:00:40,899 --> 00:00:46,529
Makefile 안에 아주 간단한 컴파일 규칙을 적습니다.

11
00:00:47,320 --> 00:00:52,619
우리가 “all”이라고 부를 이 규칙은 Makefile에 기본으로 있어야 하는 규칙입니다. 그리고 이게 바로 컴파일러가 같은 일을 하도록 시키는 규칙입니다.

12
00:00:53,289 --> 00:00:59,519
main.c, fct.c 파일로 “hello” 파일을 만들도록 하는것입니다.

13
00:01:01,480 --> 00:01:09,449
이 Makefile을 사용하기 위해서, 우리는 make라는 유틸리티를 이용할 것입니다. make는 Makefile을 읽고 가장 먼저 찾은 컴파일 규칙을 실행합니다.

14
00:01:10,570 --> 00:01:12,720
그래서 만약 우리가 “make”라고 파라미터 없이 입력하면,

15
00:01:13,960 --> 00:01:19,199
Makefile을 열어서 첫번째 규칙을 발견합니다. 규칙은 뒤에 ":"이 오는 명사를 말합니다.

16
00:01:19,680 --> 00:01:21,680
그리고 이어서 명령어를 실행합니다.

17
00:01:22,320 --> 00:01:28,440
이제 명령어 여러개를 실행할 수 있는

18
00:01:34,230 --> 00:01:36,770
두 번째 명령어를 적어봅시다.

19
00:01:37,980 --> 00:01:43,310
한번 더 “make”를 입력해보면 첫번째 규칙을 발견할 것입니다. 말하자면, “all”이 실행되는 것이죠.

20
00:01:43,800 --> 00:01:47,689
하지만 make를 실행할 때 특정 규칙을 넘겨줄 수도 있습니다. 이번에는 “coucou”로 해봅시다.

21
00:01:48,390 --> 00:01:55,130
그러면 여기 make가 먼저 “echo salut”을 실행할 것임을 보여준 뒤 “salut”를 출력합니다. 마찬가지로 “echo bonjour”도 실행할거라고 보여준 뒤, bonjour를 출력한 것을 볼 수 있습니다.

22
00:01:56,640 --> 00:02:00,470
약간 더 특수한 상황을 봅시다.

23
00:02:01,020 --> 00:02:04,939
규칙안에 잘못된 명령어가 포함된 경우입니다.

24
00:02:09,900 --> 00:02:15,500
“ls plouf”를 시도해보죠. 직접 쉘에서 실행했을때 동작하지 않는 것이 보이죠.

25
00:02:16,640 --> 00:02:23,840
그래서 만약에 제가 Makefile 안에 “coucou”라는 규칙을 실행한다면 첫번째 명령어 “echo salut”은 잘 실행됩니다.

26
00:02:25,580 --> 00:02:32,500
하지만 “ls plouf”에서 에러가 발생했죠. “make”는 즉시 중단됩니다. 

27
00:02:33,300 --> 00:02:35,300
이처럼 “Make”는 어떤 컴파일 규칙안에서 에러를 만나는 즉시 중단됩니다.

28
00:02:36,000 --> 00:02:38,209
그 뒤의 명령어는 실행되지 않죠.

29
00:02:39,540 --> 00:02:43,879
나중에 다루겠지만, 이건 아주 중요한 작동 방식입니다.

30
00:02:45,930 --> 00:02:47,930
그러면 이걸 약간 고쳐봅시다.

31
00:02:48,570 --> 00:02:50,779
예를 들어 .c 파일들을 컴파일러에 

32
00:02:51,450 --> 00:02:53,450
직접 넘겨주는 대신에

33
00:02:53,550 --> 00:02:57,350
.c 파일들을 “SRCS”라는 변수에 모아둘 수 있습니다.

34
00:02:57,660 --> 00:03:03,260
규칙이나 “:”으로 선언하는 것들과 다르게 변수는 “=“을 사용하여 선언합니다.

35
00:03:04,040 --> 00:03:07,720
"="은 우리의 .c 파일들을 가리킵니다.

36
00:03:08,120 --> 00:03:13,160
그러면 .c 파일명 대신, 여기 변수명을 적을 수 있습니다.

37
00:03:13,520 --> 00:03:19,660
그리고 make는 “${SRCS}”를 변수 내용인 “main.c”와 “fct.c”로 대체하게 됩니다.

38
00:03:20,440 --> 00:03:23,960
테스트를 해보죠…

39
00:03:24,960 --> 00:03:27,620
쨘 ! 여기 우리가 적은대로 잘 대체되었습니다.

40
00:03:28,200 --> 00:03:31,180
이게 바로 아주 간단하게 컴파일하는 방법입니다.

41
00:03:31,800 --> 00:03:34,040
이제 “fct.c” 파일을 변경한다면

42
00:03:34,340 --> 00:03:37,900
무슨 일이 일어날까요?

43
00:03:41,900 --> 00:03:44,380
예를 들어 “fct.c” 안에 글자 하나를 바꿔봅시다.

44
00:03:47,120 --> 00:03:49,920
다시 컴파일했을 때 무슨 일이 일어나는지 봅시다.

45
00:03:50,780 --> 00:03:52,780
매번, 컴파일러에 넘겨지는 모든 것들을 다시 컴파일합니다.

46
00:03:52,880 --> 00:03:58,840
즉, “main.c” “와 ”fct.c”가 다시 컴파일되었습니다. 이건 별로 효율적이지 않습니다.

47
00:04:00,140 --> 00:04:07,300
이 과정을 분석해봅시다. 먼저 컴파일러가 컴파일을 수행합니다. “cc”가 .c 파일을 .o 파일로 변환합니다.

48
00:04:07,909 --> 00:04:09,909
“main.c”를 컴파일해보죠.

49
00:04:10,580 --> 00:04:15,580
main.o이 만들어졌습니다.

50
00:04:17,180 --> 00:04:19,660
“fct.c”를 컴파일해봅시다.

51
00:04:21,530 --> 00:04:23,619
fct.o를 만들었습니다.

52
00:04:24,530 --> 00:04:28,299
이것으로 컴파일 단계는 끝났습니다.

53
00:04:29,000 --> 00:04:38,649
링킹을 위해서는 이전처럼 .c 파일을 이용하는 대신, .o 파일을 이용할 겁니다.

56
00:04:43,610 --> 00:04:46,960
자, 제가 만든 "hello" 바이너리 파일이 잘 동작합니다. (Hello World ! 가 잘 출력되었기 때문에!)

57
00:04:49,280 --> 00:04:57,300
다른 방식으로 다시 만들어봅시다. 만약 우리가 지금 Hello world를 수정한다면,

58
00:04:58,900 --> 00:05:04,570
반드시 fct.c를 다시 컴파일해야 합니다.

60
00:05:04,820 --> 00:05:10,449
fct.c만 컴파일해서 새로 만들어진 fct.o 바이너리 파일을 re-link할 수 있습니다. 우린 fct.c만 변경했으므로, main.c를 main.o로 re-compile할 필요가 전혀 없습니다.

61
00:05:11,080 --> 00:05:15,640
이게 Makefile이 알아서 해줬으면 하는 것들입니다.

62
00:05:17,860 --> 00:05:22,640
먼저, 오브젝트 파일들을 모아 놓을 변수를 만들겠습니다.

63
00:05:23,720 --> 00:05:25,720
변수 "OBJS"라고 하죠.

64
00:05:26,420 --> 00:05:30,500
그리고 OBJS변수는 SRCS 변수부터 시작한다고 적어줍시다. ${SRCS:

65
00:05:30,920 --> 00:05:34,660
간단하게 확장자 .c를 확장자 .o로 변환할 수 있습니다. ${SRC:.c=.o}

66
00:05:37,039 --> 00:05:41,619
여기서 .c 파일들을 컴파일하는 대신, .o 파일들을 링킹하도록 변경합시다.

67
00:05:42,139 --> 00:05:44,649
그러니 ${SRCS}를 ${OBJS}로 변경합니다.

68
00:05:47,260 --> 00:05:49,260
SO EZZZZZZZZZ

69
00:05:49,660 --> 00:05:51,580
“make”를 실행해보면

70
00:05:51,580 --> 00:05:54,990
.c 파일들이 .o 파일들로 잘 바뀌었습니다.

71
00:05:56,110 --> 00:06:00,600
문제는 우리가 거의 처음부터 다시 시작할 때입니다.

72
00:06:01,450 --> 00:06:04,170
.o 파일들과 hello파일을 다 지워볼까요.

73
00:06:06,400 --> 00:06:12,420
Makefile에 적힌 것들과는 다르게 우리는 .c파일들만 가지고 있습니다.

74
00:06:13,200 --> 00:06:15,160
자...이제 make를 다시 실행하면 error가 발생합니다.

75
00:06:15,160 --> 00:06:20,100
존재하지 않는 .o 파일을 컴파일러에게 요구했기 때문이에요.

76
00:06:20,530 --> 00:06:22,530
우리는 Makefile에게 필요한 것을 말해주지 않았습니다.

77
00:06:23,290 --> 00:06:29,280
각 규칙들에 앞서 의존관계를 설정할 수 있습니다. “이 규칙을 실행시키려면 이게 필요해” 라고 말하기 위해서요.

78
00:06:29,620 --> 00:06:33,030
그러므로 우리에게 실질적으로 필요한 것은 .o 파일들입니다.

79
00:06:34,510 --> 00:06:37,620
그래서 우리는 간단하게 말할 수 있습니다. " ‘.o’가 필요해"

80
00:06:39,310 --> 00:06:44,910
그러면 Makefile은 ".o"파일을 만들기 위해 그에 맞는 “.c"파일을 컴파일해야 한다는 것을 이해할 것입니다.

81
00:06:46,480 --> 00:06:53,340
Make를 다시 입력하면, .c 파일들에서 .o 파일들을 만들어냅니다.

82
00:06:56,200 --> 00:07:00,320
make를 다시 실행하면, 이미 .o 파일들이 있습니다.

83
00:07:00,780 --> 00:07:05,980
그래서 다시 컴파일할 필요가 없고, "all" 규칙을 실행합니다.

84
00:07:06,610 --> 00:07:12,210
이미 컴파일되어있기 때문에 의존 규칙을 실행하지 않습니다.

85
00:07:13,440 --> 00:07:19,780
이제, 제가 fct.c를 수정하고 저장한 뒤 make를 다시 실행하면,

86
00:07:28,180 --> 00:07:36,060
fct.c만 컴파일하고, 컴파일 된 “.o"가 만들어지면서 ".o”를 링크합니다.

87
00:07:36,700 --> 00:07:40,560
이렇게 컴파일을 훨씬 쉽게 할 수 있습니다.

88
00:07:40,840 --> 00:07:47,040
만약 백여 개의 파일들이 있다면 매번 수정된 파일들만 컴파일할 겁니다.

90
00:07:47,230 --> 00:07:54,870
조금만 더 나아가자면 “Hello” 파일을 다시 만들기 위해서, 필요한 파일만 링킹하도록 만들수도 있습니다.

92
00:07:55,270 --> 00:07:59,469
그러기 위해서는 그저 규칙을 부르기만 하면 됩니다.

93
00:08:00,880 --> 00:08:03,900
기본적으로는 컴파일하고자 하는 바이너리의 이름입니다.

94
00:08:09,860 --> 00:08:14,620
이 파일들을 지우겠습니다.

95
00:08:16,060 --> 00:08:21,500
“make”를 할 때 기본적으로 첫 번째 규칙을 받아들이기 때문에, “hello” 규칙을 발견하고 “hello” 파일이 이미 존재하는지 확인합니다.

96
00:08:22,540 --> 00:08:25,540
만약 존재하지 않는다면 hello 규칙을 실행합니다.

97
00:08:27,220 --> 00:08:30,199
그리고 같은 방식으로

98
00:08:30,199 --> 00:08:33,968
“hello”는 일종의 의존관계도 될 수 있습니다. 만약 “hello”가 “OBJS” 파일들보다 더 오래되었다면 

99
00:08:34,879 --> 00:08:37,419
chelee: hello 파일을 다시 만들것입니다.

100
00:08:37,759 --> 00:08:41,409
이건 말하자면 우리의 .o 파일들이 바이너리 파일보다 더 최신이라는 거죠.

101
00:08:42,050 --> 00:08:47,319
만약 바이너리 파일이 더 오래되었을 때 .o 파일들로부터 바이너리 파일을 새로 생성하는 건 가능하지만, 같은 규칙이 .o 파일에 적용될 수는 없습니다.

102
00:08:48,079 --> 00:08:49,490
왜냐하면, hello를 잘 만들었고 

103
00:08:49,490 --> 00:08:55,540
hello가 .o 파일들보다 최신이라면 그건 .o 파일들을 방금 전에 만들었으니, .o 파일들을 다시 만들 필요가 없다는 뜻이죠.

104
00:08:55,780 --> 00:08:59,180
그러면 make는 우리에게 알려줄 겁니다. hello는 최신 파일이니 뭔가를 더 할 필요가 없다고요.

105
00:08:59,720 --> 00:09:06,040
그러므로 여기 우리가 만든 최적화된 컴파일러는 절대 다시 컴파일하지 않을 겁니다. 왜냐하면 컴파일되어야 하는 것이 아무것도 없기 때문이죠!  

106
00:09:06,620 --> 00:09:11,380
이제 Makefile을 이용해 컴파일하는 것은 이렇게나 쉽고 효율적이라고 말할 수 있습니다~ (짜란)

translated by inyang, chelee, mki and yeslee :)
