1
00:00:00,069 --> 00:00:04,048
Makefile로 할 수 있는 것들을 조금 더 자세하게 볼 수 있는 이 비디오에 오신 여러분들 환영합니다. 

2
00:00:04,870 --> 00:00:12,330
그럼, 우리는 main.c fct.c를 "hello"라는 바이너리로 컴파일하는 매우 단순한 makefile로 시작할 겁니다.

3
00:00:12,849 --> 00:00:17,849
이 “hello” 규칙은 우리의 바이너리 파일이 있는지를 확인할 겁니다.  

4
00:00:18,310 --> 00:00:21,750
우리는 먼저 NAME에 우리 바이너리 파일의 이름을 줄 거예요.

5
00:00:22,630 --> 00:00:27,090
이제 이 NAME을 규칙의 이름으로, 또 컴파일 할 바이너리 파일의 이름으로 사용할 겁니다.

6
00:00:28,120 --> 00:00:30,720
그렇게 함으로써 아주 간단하게

7
00:00:31,980 --> 00:00:34,440
“hello”를 $(NAME)으로 대체할 수 있죠. 여기도 있네요.

8
00:00:35,560 --> 00:00:37,480
그래서 우리는 확신할 수 있습니다

9
00:00:37,480 --> 00:00:44,180
우리가 만들 바이너리 파일과 그에 상응하는 규칙이 같으므로,

10
00:00:44,940 --> 00:00:47,620
규칙의 결과로 만들어질 바이너리 파일 이름과 규칙 이름이 항상 같으리라는 것이죠.

11
00:00:49,380 --> 00:01:00,060
여기 의존관계인 $(OBJS)는 "hello" 규칙을 위해 .o 파일들이 필요하다고 말하는 것입니다.

12
(위에서 언급)

13
00:01:00,070 --> 00:01:03,100
이렇게, makefile에는 숨겨진 규칙이 있습니다.

14
00:01:04,000 --> 00:01:11,060
“make”는 .c를 .o로 바꾸는 규칙을 기본으로 포함하고 있다는 것입니다.

15
00:01:12,100 --> 00:01:15,150
그리고 이 규칙은 그냥 실행되기 때문에 의존규칙이 없습니다.

16
00:01:15,820 --> 00:01:17,820
대체로

17
00:01:18,070 --> 00:01:19,630
이 규칙은

18
00:01:19,630 --> 00:01:21,630
이 내용과 일치합니다.

19
00:01:24,430 --> 00:01:29,189
즉, 이 규칙은 ${cc}로 지정된 컴파일러에게 전달됩니다.

20
00:01:29,500 --> 00:01:36,689
따라서, 우리가 ${CC}에 gcc, clang을 입력하는 것으로 컴파일러를 즉시 변경할 수 있습니다. 일단은 cc로 남겨놓겠습니다.

21
00:01:38,500 --> 00:01:43,290
.c.o는 $(CFLAGS)도 있는데, 우린 CFLAGS에게 includes나 컴파일 flag들을 줄 수 있습니다.

22
00:01:45,670 --> 00:01:47,670
예를 들면 -Wall

23
00:01:48,700 --> 00:01:51,360
-g 등등


24
00:01:53,380 --> 00:01:55,380
그러면, Makefile은

25
00:01:55,780 --> 00:02:01,589
우리가 입력한 .c파일을 컴파일할 것이고, 그럼 여기서 .c파일들을 대체할 특수문자 ‘<’를 입력합시다.

26
00:02:02,259 --> 00:02:07,379
그러면 컴파일러는 .o를 생성할 것이고, 그리고 우리가 SRC에 입력한것과 같은 것들을

27
00:02:07,690 --> 00:02:11,889
다시 시작할 겁니다.

28
00:02:12,980 --> 00:02:18,039
이 “<”를 가지고 우리는 .c를 .o로 대신할 겁니다.

29
00:02:20,270 --> 00:02:24,939
자, 여기서 우리는 .c를 .o로 바꾸는 숨겨진 규칙을 재정의했습니다.

30
00:02:25,970 --> 00:02:29,259
똑같이 cc도 ${CC}로 변경해줍니다. 큰 이유는 없지만요.

31
00:02:30,260 --> 00:02:36,700
일반적으로, 우리의 바이너리 파일들을 변수로 정의하는 것은 좋은 방법입니다.
 
32
00:02:39,110 --> 00:02:42,069
“all”이라고 부르는 기본 규칙을 추가하겠습니다

33
00:02:42,620 --> 00:02:45,610
관습적으로 “make all”을 기본 규칙으로 사용하곤 합니다.

34
00:02:46,190 --> 00:02:49,179
그리고 “all”은 단순히 ${NAME}만을 의존 관계로 가집니다.

35
00:02:49,910 --> 00:02:56,169
all은 ${NAME}을 부르는 것 외에 특정한 행동을 하지 않습니다. 이것이 all의 기본 동작이기 때문이에요.

36
00:02:58,400 --> 00:03:00,400
좋습니다.

37
00:03:01,010 --> 00:03:06,670
그래서, 만약 “make all”을 하면, 아이고 여기 오타가 났군요

38
00:03:08,030 --> 00:03:10,030
“make all”을 하면

39
00:03:10,790 --> 00:03:13,209
자, make는 우리에게 다시 컴파일할 ${NAME}이 있다고 알려줍니다.

40
00:03:14,420 --> 00:03:19,299
그래서 “hello”는 이미 폴더에 있어서, 저는 다시 컴파일할 필요가 없군요.

41
00:03:20,180 --> 00:03:24,640
“all”은 그 자체로는 “make”나 “make hello”와 다를 바가 없습니다.

42
00:03:25,130 --> 00:03:30,070
같은 규칙이거든요. 첫 번째 규칙에 의해서 모든 파일이 최신입니다.

43
00:03:30,920 --> 00:03:35,500
“hello”를 지우고 “make all”을 하면, ${NAME}이 호출되고,

44
00:03:36,980 --> 00:03:38,980
“hello” 파일이 컴파일되겠죠.

45
00:03:39,320 --> 00:03:43,899
그리고 여러분들은 "hello"파일을 만들기 위해 디렉토리 안에 .o를 만든 것을 볼 수 있습니다.

46
00:03:44,540 --> 00:03:46,719
이제 “clean” 규칙을 만들어봅시다.

47
00:03:47,720 --> 00:03:51,009
이 “clean” 규칙은 .o 파일들을 지우는 명령어입니다.

48
00:03:52,160 --> 00:03:54,519
“rm ${OBJS}”를 한 번 써볼까요.

49
00:03:57,320 --> 00:03:59,320
해봅시다.

50
00:04:01,300 --> 00:04:06,160
자, main.o, fct.o 파일을 지웠습니다. 만약에 더 나아가서...

51
00:04:06,280 --> 00:04:09,180
이것보다 더 깔끔하게

52
00:04:09,680 --> 00:04:11,680
예를 들면 바이너리 파일까지 지우고 싶다면,

53
00:04:12,290 --> 00:04:15,519
“fclean” 규칙을 만들면 됩니다. 두 가지 명령을 실행할 일종의 강제성을 지닌 “clean”입니다.

54
00:04:16,130 --> 00:04:20,499
먼저 “clean” 규칙을 다시 부르고,

55
00:04:21,440 --> 00:04:23,440
이어 “rm”과 “rm”으로 지울 바이너리 파일,

56
00:04:24,190 --> 00:04:26,249
그러니까 ${NAME}을 추가합시다.

57
00:04:28,210 --> 00:04:30,900
좋습니다 “rm”이 추가된 의존 규칙이 만들어졌습니다.

58
00:04:32,860 --> 00:04:35,550
자, 해볼까요. 먼저 디렉토리에 무슨 파일들이 있는지 보여드릴게요.

59
00:04:36,910 --> 00:04:40,859
이제 “make fclean”으로 .o 파일들과 “hello” 파일을 지울건데,

60
00:04:42,010 --> 00:04:47,039
작동하지 않죠. 무슨 일이 일어났는지 봅시다.

61
00:04:47,740 --> 00:04:52,140
“fclean”이 말합니다: “clean” 규칙을 실행하는데, 거기엔 의존 규칙이 없어

62
00:04:53,200 --> 00:04:55,619
그래서 .o 파일들을 “rm”할 것입니다. 

63
00:04:56,140 --> 00:04:58,140
.o 파일들을 “rm”하는 명령은

64
00:04:58,240 --> 00:05:01,920
rm “*.o” 명령과는 다릅니다. 지워야 할 .o 의 목록이 있기 때문입니다.

65
00:05:02,100 --> 00:05:05,360
다른 파일을 지워버릴 걱정은 없기 때문에 좋죠.

66
00:05:06,070 --> 00:05:10,469
이전 단계에서 지워버린 main.o, fct.o를 제외한 다른 파일들을요.

67
00:05:10,960 --> 00:05:16,769
여러분은 보지 못했겠지만, 직전에 저는 .o 파일들을 지웠습니다. 그래서 에러를 발생시켰고 “make”가 멈춘 거예요.

68
00:05:17,080 --> 00:05:25,649
여기서부턴 더 진행할 필요가 없습니다. 그래서 rm $(NAME)은 실행되지 않을 겁니다.

70
00:05:26,230 --> 00:05:31,830
단순히 이 문제를 변수 RM을 선언하고 rm을 수정하는 것으로 이 문제를 해결할겁니다.

71
00:05:32,440 --> 00:05:37,499
“rm” 명령과 -f 옵션을 사용함으로써 “RM” 변수를 정의할 것입니다

72
00:05:38,050 --> 00:05:40,050
clean 변수로 가서 

73
00:05:41,110 --> 00:05:43,110
rm을 $(RM)으로 바꿔줍니다

74
00:05:47,569 --> 00:05:52,729
이제 매번 “rm -f”를 실행할 거예요. 만약 제가 여기서 다시 시작한다면, “make fclean”은 .o 파일들을 “rm -f” 할 겁니다.

75
00:05:52,860 --> 00:05:56,899
.o 파일들은 존재하지 않지만 중요한 건 아니에요. 그리고 “hello”도 “rm -f”합니다.

76
00:05:59,159 --> 00:06:01,159
짜잔, 더욱 간단해졌습니다

77
00:06:01,949 --> 00:06:07,968
우리는 이제 강제로 다시 컴파일하는 규칙까지 만들 수 있습니다. 말하자면 제가 여기서 make를 실행했더라도,

78
00:06:08,249 --> 00:06:13,278
파일이 실행되지 않거나 오래되었기 때문이거나, 아무튼 파일들을 다시 컴파일하기를 원하면 

79
00:06:13,919 --> 00:06:19,308
그저 “fclean”과 “all” 규칙을 부르는 것으로 “re” 규칙을 실행할 수 있습니다.

80
00:06:21,419 --> 00:06:28,398
그리고 “make re”를 하면, 강제로 모든 것을 지우고 다시 컴파일할 것입니다

81
00:06:29,940 --> 00:06:33,120
만약 여러분이 잘 따라왔다면, 여기에 주목하세요.

82
00:06:34,560 --> 00:06:38,660
마지막으로 규칙 이름과 파일 이름이 같을 때 생기는 문제를 보겠습니다 

83
00:06:39,560 --> 00:06:41,560
“make hello”를 실행하면

84
00:06:42,400 --> 00:06:45,760
“hello” 규칙은 실행되지 않습니다. “hello”가 이미 존재하기 때문입니다

85
00:06:46,640 --> 00:06:51,980
만약 all 파일이 디렉토리 안에 있다면 어떤 일이 일어날까요

87
당연히 all은 실행되지 않습니다.

88
자, “clean”은 최신 파일이니 “make clean” 명령을 실행할 필요가 없습니다.

89
왜냐하면 이미 디렉토리에 “clean” 파일이 있으니 신경 쓸 필요가 없는 거죠.

90
00:07:11,039 --> 00:07:13,039
그래서 우리는 Makefile에게

91
00:07:13,589 --> 00:07:16,458
어떤 파일들을 특별하게 말해줘야 합니다. (.PHONY: )

92
00:07:17,669 --> 00:07:19,669
그게 뭐냐면...

93
00:07:20,399 --> 00:07:21,629
거기 없는…

94
00:07:21,629 --> 00:07:29,299
미안합니다. 파일로서 해석을 하면안되는 "all” "clean” “fclean" 규칙들을 알려줘야 합니다. 

95
00:07:31,949 --> 00:07:33,949
“re”도 마찬가지입니다

96
00:07:35,680 --> 00:07:43,669
그러니 여기서 “make clean”을 하면, “make clean”은 “clean” 파일이 이미 있든 없든 신경쓰지 않고 실행될 겁니다.

98
00:07:43,669 --> 00:07:46,839
지금까지 조금 더 나아진 Makefile을 함께 봤습니다. (짝짝짝)

translated by inyang, chelee, mki and yeslee :)
