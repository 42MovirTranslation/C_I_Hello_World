1
00:00:00,000 --> 00:00:01,240
이번 영상에선

2
00:00:01,240 --> 00:00:05,280
그래프 대신 더욱 실질적인 예시를 보여드리겠습니다.

3
00:00:05,528 --> 00:00:09,268
c 언어를 사용할 건데요. 연결 리스트 안을 어떻게 넘어 다니는지 보여드리죠.

4
00:00:09,460 --> 00:00:14,729
하지만 그 전에 우선 연결된 리스트를 만들어야겠죠. 자, “s_list” 구조체가 있습니다.

5
00:00:15,070 --> 00:00:20,760
전과 같이 “int i”, “char c”, 그리고 “next” 포인터를 가진 “struct s_list” 입니다.

6
00:00:21,160 --> 00:00:23,399
좋아요. 연결 리스트를 만들 준비물을 다 갖췄군요.

7
00:00:24,440 --> 00:00:32,140
이제 연결 리스트에 세 요소를 엮을 겁니다. 먼저 “struct s_list”를 불러오겠습니다.

8
00:00:33,219 --> 00:00:35,219
첫 번째 요소는 “elem1”이라고 부르죠.

9
00:00:36,119 --> 00:00:39,119
두 번째는 “elem2”, 세 번째는 “elem3”

10
00:00:39,299 --> 00:00:43,419
배열을 사용해도 되지만 그러지 않았습니다. 이 세 요소가 전부

11
00:00:43,520 --> 00:00:47,520
개별의 요소라는 것을 보여드리고 싶었거든요. 특별히 메모리로 연결되어 있지 않은 개별 요소들입니다.

12
00:00:48,359 --> 00:00:55,989
이제 “struct s_list begin”, 아니 “* begin”을 만듭니다.

13
00:00:55,988 --> 00:01:00,598
첫 요소를 가리키는 포인터입니다. 벌써 리스트가 완성됐군요.

14
00:01:01,030 --> 00:01:03,960
요소들을 전부 뭉친 리스트를 만들 겁니다.

15
00:01:05,159 --> 00:01:08,140
“begin”은 무엇을 가질까요? “elem1”의 주소입니다.

16
00:01:09,400 --> 00:01:16,300
“elem1.next”는 “elem2”의 주소를 가지고요.

17
00:01:17,480 --> 00:01:19,859
"elem2.next"는

18
00:01:20,540 --> 00:01:23,200
“elem3”의 주소를 가지죠.

19
00:01:23,579 --> 00:01:28,159
그리고 “elem3.next”는 0을 가집니다.

20
00:01:28,659 --> 00:01:30,759
그래서 보시면 “begin”은

21
00:01:30,939 --> 00:01:35,980
“elem1”을 가리키고요, “elem1”의 안에 있는 포인터 “next”는 “elem2”를 가리키죠.

22
00:01:36,540 --> 00:01:42,480
“elem2”의 포인터는 “elem3”을, “elem3”의 포인터는 0을 가리킵니다. 연결 리스트가 끝났다는 뜻이죠.

23
00:01:42,959 --> 00:01:44,959
자, 됐습니다. 아주 간단하죠.

24
00:01:45,188 --> 00:01:52,108
이제 어떻게 쓰는지, 몇 가지 속성을 보여드리겠습니다. 예를 들어, “elem3” 안에

25
00:01:53,409 --> 00:01:57,929
“i”를 42로 맞춥니다. 그게 답니다. 이제 이걸 출력해보겠습니다.

26
00:02:00,968 --> 00:02:03,838
그러니까 “%d\n”을 쓰고

27
00:02:04,599 --> 00:02:07,519
"elem3.i"

28
00:02:07,900 --> 00:02:12,599
괄호를 닫고, 세미콜론을 하고 됐습니다. 컴파일하면 42가 출력됐습니다.


29
00:02:12,979 --> 00:02:15,859
이번에는 “elem2”를 이용하여 “elem3”에 접근하고 싶군요.

30
00:02:17,000 --> 00:02:21,800
“elem2.next”는 “elem3->”의 주소입니다.

31
00:02:22,360 --> 00:02:26,300
이렇게 “elem3”으로 이동했습니다. 이제 “elem3”의 어느 부분에 접근해야 할까요.

32
00:02:26,960 --> 00:02:28,960
“i”이죠.

33
00:02:29,870 --> 00:02:34,780
이렇게 42가 나왔습니다. 완벽합니다. 자, 이번엔 “elem1”로 같은 일을 해보고 싶군요.

34
00:02:35,090 --> 00:02:37,929
“elem1”은 “elem2”에 접근할 수 있으니 쉽군요.

35
00:02:38,599 --> 00:02:40,599
"elem1.next->”

36
00:02:41,159 --> 00:02:45,719
이 사이에 화살표를 넣어주면, 이제 “elem2”로 옮겨온 겁니다. 다음으로 “elem2”의 “next”로 갑니다.

37
00:02:45,800 --> 00:02:50,320
여기서 “elem2”의 next에 있는 거고요. 결국 “elem3->i”의 주소인 거지요. 홉

38
00:02:50,590 --> 00:02:57,819
자, 다시 한번 전과 같은 곳에 도달했습니다. 언제나 42를 출력하는 거죠. 완벽해요. 이번엔 첫 시작인 “begin”에서 시작해봅시다.

39
00:03:00,469 --> 00:03:02,469
“begin”은 포인터이므로 화살표를 씁니다.

40
00:03:02,539 --> 00:03:09,419
이 안에서 역참조를 했으니 “elem1”의 안에 와있는 겁니다. 그러니 이 “next”는 “elem1”의 것이죠.

41
00:03:10,180 --> 00:03:15,819
이다음 “next->”는 역참조로 “elem2”의 “.next”이지요.

42
00:03:16,259 --> 00:03:19,099
다시 화살표니까 역참조를 하면, 이제

43
00:03:19,419 --> 00:03:24,559
“elem3”의 “i”를 보고 있는 겁니다. 자 이제 똑같은 값이 나올 겁니다. 그렇습니다.

44
00:03:25,360 --> 00:03:28,320
이 모든 방법으로  “elem3”에 도달할 수 있음을 깨달았습니다.

45
00:03:28,840 --> 00:03:31,800
매우 길고 지루하고 실용적이지 않지요.

46
00:03:32,500 --> 00:03:35,460
게다가, 예를 들어, “elem1”의 값이나

47
00:03:35,659 --> 00:03:39,039
“elem2”, “elem3”의 값을 출력한다고 칩시다. “elem1”에는 값을

48
00:03:40,419 --> 00:03:43,979
98로 주고, “elem2”에는

49
00:03:45,240 --> 00:03:47,240
109를 줍시다. 좋아요.

50
00:03:48,379 --> 00:03:52,060
자, 이제 이 모든 값을 출력한다고 합시다.

51
00:03:52,960 --> 00:03:56,180
그러면 이제 이렇게 해야겠죠.

52
00:03:56,560 --> 00:04:01,840
이렇게 직접적으로 적으면 이 줄은 “elem1”을, 이것은 “elem2”, 요거는 “elem3”를 출력합니다.

53
00:04:02,099 --> 00:04:04,539
그다지 실용적이지 않죠.

54
00:04:05,039 --> 00:04:11,759
만약 새로운 요소를 추가하고 싶다면, 코드는 아무래도 … 한 땀 한 땀 손으로 직접 추가해야 하겠죠.

55
00:04:11,840 --> 00:04:15,860
알맞은 개수의 요소들 등등 말이죠. 그리고 만약 사용자 입력을 저장하는 연결 리스트였다면

56
00:04:16,060 --> 00:04:20,139
모든 게 매우 복잡해지죠. 제 리스트 전부를 탐색하고 각각의 요소들을 출력할 수 있는

57
00:04:20,860 --> 00:04:23,860
함수를 만들어야 합니다.

58
00:04:24,519 --> 00:04:28,840
그럼 한번 해보죠.

59
00:04:30,000 --> 00:04:35,839
현재 아이템을 출력하고 다음으로 넘어가는 함수를 만들어 봅시다. 탐색하고 출력하는 함수 말이죠.

60
00:04:36,699 --> 00:04:45,489
자, 어떻게 할까요? aff_list라 불리는 “void”를 만들어서 “struct s_list”를 받게 합시다.

61
00:04:45,490 --> 00:04:47,960
“*”인 포인터로요. “begin”이라고 부릅시다.

62
00:04:48,540 --> 00:04:50,540
좀 더 알아보기 쉽겠죠.

63
00:04:52,319 --> 00:04:55,439
이제 시작부터 하나 혹은 그 이상의 요소를 가리키는 포인터를 가지고 있습니다.

64
00:04:55,920 --> 00:04:58,780
다음으로, 저는 제 리스트를 그다지 정확하게

65
00:04:58,920 --> 00:05:01,600
알고 있지 않다고 합시다. 얼마나 많은 요소를 담고 있는지 모르죠.

66
00:05:01,860 --> 00:05:05,240
좀 전에 말했듯이 만약 “begin”이 0과 같다면, 아무런 요소도 없다는 뜻입니다.

67
00:05:05,860 --> 00:05:08,480
좋아요. 그럼 이렇게 적을 수 있겠죠.

68
00:05:10,079 --> 00:05:13,699
"if (!begin)", “begin이 0이라면"

69
00:05:15,060 --> 00:05:19,199
“return” 하라. 그러니까 요소가 없다면 이 함수를 떠나라.

70
00:05:21,519 --> 00:05:25,819
이제 반복문을 만듭니다. 각 요소를 탐색하고 싶으니까요.

71
00:05:25,959 --> 00:05:30,899
그래서 이 반복문에 들어오면, 제가 무엇을 적는지 보십쇼.

72
00:05:31,779 --> 00:05:36,329
저 “if”문은 아직은 필요 없을지 모르겠지만 일단은 놔두겠습니다.

73
00:05:36,668 --> 00:05:38,668
제 반복문이 궁금하시죠?

74
00:05:38,939 --> 00:05:43,680
현재 어느 요소에 있는지 출력할 겁니다. “begin”이 어떤 요소를 가리킬 것이고 그 안에 있는 것을 출력하는 거죠.

75
00:05:46,000 --> 00:05:51,800
“printf”로 “%d\n”를 해서 “begin->i”를 출력합시다.

76
00:05:54,060 --> 00:05:56,759
이 요소를 출력했으니, 이제 다음 요소로 넘어가고 싶군요.

77
00:05:57,180 --> 00:06:02,900
아시다시피 다음 요소의 주소는 “begin->next”입니다.

78
00:06:03,339 --> 00:06:06,980
그러니 예를 들어 이렇게 했다면,

79
00:06:07,589 --> 00:06:13,789
“aff_list”의 “begin”은 맘대로 바꿔도 됩니다. 왜냐하면 복사본이기 때문이지요.

80
00:06:13,790 --> 00:06:15,510
매개변수를 건네줄 겁니다.

81
00:06:15,509 --> 00:06:19,420
그러면 처음에 “begin”은 첫 요소를 가리키죠.

82
00:06:20,240 --> 00:06:23,680
그리고 그다음으로 이 밑의 주소를 받으러 갑니다. 두 번째 요소이지요.

83
00:06:24,300 --> 00:06:27,978
그 주소를 제 begin에 넣고요. 그럼 결과적으로 제 “begin”은 이제 두 번째 요소를 가리킵니다.

84
00:06:28,620 --> 00:06:30,620
그렇습니다.

85
00:06:30,839 --> 00:06:33,799
리스트를 한 번 돌고 나면 바로 이 순간

86
00:06:34,050 --> 00:06:38,028
“begin”은 마지막 요소 값을 가지죠. 마지막 요소 값은 0입니다.

87
00:06:38,699 --> 00:06:44,269
그러니까 만약 “begin”이 0이 아닌 값을 가지면 반복문을 돌지만, 0이라면 반복문을 탈출합니다.

88
00:06:44,490 --> 00:06:46,790
그리고 어떻게 보나 이 “if”문은 무용지물이군요.

89
00:06:48,240 --> 00:06:55,189
됐습니다. 리스트를 전부 탐색하고 출력하는 반복문을 만들었습니다. 매우 간단하죠.

90
00:06:56,779 --> 00:07:02,379
이제 이걸 모두 지우겠습니다. 제 함수를 불러와서 “aff_list”에 “begin”을 넘겨주도록 합시다.

91
00:07:04,439 --> 00:07:06,290
무슨 일이 일어나는지 볼까요.

92
00:07:06,290 --> 00:07:10,819
98 109 42. 잘 동작하는군요. 다시 한번 정리하면,

93
00:07:11,579 --> 00:07:14,199
“begin”은 첫 번째 요소 “elem1”의 주소를 가지고요.

94
00:07:15,120 --> 00:07:18,439
“begin”은 0이니? 놉

95
00:07:18,810 --> 00:07:23,178
좋아. 그럼 이제 반복문으로 들어가고,
“begin”이 가리키는 주소에 무엇이 있는지 봅니다.

96
00:07:23,430 --> 00:07:30,170
“i”가 있음을 확인하고, 값은 98이군요. “elem1.i”는 98이니까요. 좋아요.

97
00:07:30,959 --> 00:07:32,959
다음으로

98
00:07:33,060 --> 00:07:38,119
“begin”이 가리키는 주소 안에 있는 “next”를 받아요.
“next”는 다음 주소를 가리키는 포인터죠.

99
00:07:38,120 --> 00:07:42,949
“elem2”의 주소를 받아온 겁니다. 그 주소를 “begin”에게 주었어요.

100
00:07:43,339 --> 00:07:45,779
그러고 다시 시작합니다. begin은 0을 가지고 있니? 놉

101
00:07:46,100 --> 00:07:50,640
그럼 다시 “begin”이 가리키는 주소로 가서 “i”를 찾고 출력합니다.

102
00:07:51,300 --> 00:07:54,590
그다음으로 똑같이 “begin”이 가리키는 주소에서

103
00:07:54,810 --> 00:07:58,488
“next”를 받고요 “next”가 가진 주소를 가집니다.

104
00:07:59,029 --> 00:08:06,078
“elem2”의 “next”는 “elem3”의 주소죠. “begin”이 0인가요?
놉. 그러므로 여기로 갑니다.

105
00:08:06,500 --> 00:08:12,420
가리킨 주소로 가서 “i”를 가져와 출력하고 가리킨 주소의 “next”를 받습니다.

106
00:08:12,540 --> 00:08:15,800
“begin”에 넣어주고요. 하지만 “elem3”의 “next”는 0을 가지고 있지요.

107
00:08:16,350 --> 00:08:17,550
여기로 오면

108
00:08:17,550 --> 00:08:21,480
“begin”이 0이 아닌 다른 값을 가지고 있나요? 아니요. 그렇지 않아요. 0입니다.

109
00:08:21,699 --> 00:08:26,120
그렇게 리스트를 한 번 돌았습니다. 연결 리스트를 탐색했습니다.

111
00:08:26,670 --> 00:08:29,299
이렇게 하는 겁니다. 연결 리스트를 탐색하는 코드의 예시입니다.

112
00:08:30,000 --> 00:08:36,019
연결 리스트를 탐색할 때 리스트를 가리키는 포인터나 그 포인터의 포인터를 자주 사용합니다.

113
00:08:36,360 --> 00:08:40,099
직접적으로, 예를 들어, “next”에 접근할 수 있기 때문이지요.

114
00:08:40,769 --> 00:08:43,490
나중에 활용 예제 같은 것들에서 보게 될 겁니다.

115
00:08:43,830 --> 00:08:49,730
어쨌거나 이것이 연결 리스트 안을 어떻게 돌아다니는지 보여주는 첫 예시였습니다.
<< translated by mseo, inyang, mki, yeslee, and ji-kim :D >>
